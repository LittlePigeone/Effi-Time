{% extends 'index.html' %}

{% block links_block %}
    <link rel="stylesheet" href="../static/first_app/css/canban.css">
    <style>
        .column {
            transition: background-color 0.2s ease;
        }
        .column.drag-over {
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        .task {
            cursor: grab;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .task:active {
            cursor: grabbing;
        }
        .task.dragging {
            opacity: 0.5;
            transform: scale(0.98);
        }
    </style>
{% endblock %}



{% block content %}
    <div class="right_panel glass-block">
        <div class="bottom_buttons">
            <input type="text" class="search glass-block" placeholder="Поиск по названию">
            
            <div class="add_task glass-block" onclick="open_create_task_page()">
                <h1 class="canban_text">Добавить задачу</h1>
            </div>

        </div>
        
        <div class="conban-column">
            <div class="conban-board">


                <div class="add_category">

                </div>
            </div>
        </div>
    </div>

    <script type="text/javascript">
        const categoryId = new URLSearchParams(window.location.search).get('category_id');
        window.defaultCategoryId = categoryId ? parseInt(categoryId, 10) : null;

        let taskSearchQuery = "";

        function applyTaskFilter() {
            const q = (taskSearchQuery ?? "").toString().trim().toLowerCase();
            const tasks = document.querySelectorAll('.task[data-name]');
            tasks.forEach((el) => {
                if (!q) {
                    el.style.display = '';
                    return;
                }
                const name = (el.dataset.name ?? "").toString().toLowerCase();
                el.style.display = name.includes(q) ? '' : 'none';
            });
        }

        function initTaskSearch() {
            const input = document.querySelector('.search');
            if (!input) return;
            input.oninput = () => {
                taskSearchQuery = input.value ?? "";
                applyTaskFilter();
            };
            input.onkeydown = (e) => {
                if (e.key === 'Escape') {
                    input.value = '';
                    taskSearchQuery = '';
                    applyTaskFilter();
                }
            };
        }

        async function setHTMLWithScripts(container, html) {
            container.innerHTML = html;

            const scripts = Array.from(container.querySelectorAll("script"));

            for (const oldScript of scripts) {
                const newScript = document.createElement("script");

                // копируем атрибуты
                for (const attr of oldScript.attributes) {
                    newScript.setAttribute(attr.name, attr.value);
                }

                if (oldScript.src) {
                    // ВАЖНО: ждём загрузку src
                    await new Promise((resolve, reject) => {
                        newScript.onload = resolve;
                        newScript.onerror = reject;
                        document.body.appendChild(newScript);
                    });
                } else {
                    // inline — выполняем после загрузки всех src выше
                    newScript.textContent = oldScript.textContent;
                    document.body.appendChild(newScript);
                }

                oldScript.remove();
            }
        }

        function show_canban_list() {
            request({
                url: categoryId ? `/task/canban/?category_id=${encodeURIComponent(categoryId)}` : '/task/canban/',
            }).then(data => {
                const canban_board = document.querySelector(".conban-board");

                // очистка доски перед перерисовкой
                canban_board.innerHTML = "";

                data.forEach((column) => {
                    // ---------- колонка ----------
                    const columnDiv = document.createElement("div");
                    columnDiv.className = "column";
                    columnDiv.dataset.id = column.id;

                    // Add drag events to column
                    columnDiv.addEventListener('dragover', handleDragOver);
                    columnDiv.addEventListener('dragleave', handleDragLeave);
                    columnDiv.addEventListener('drop', handleDrop);

                    columnDiv.innerHTML = `
                        <div class="column_title" style="background-color: ${column.color}4D">
                            <h1 class="canban_text">${column.name}</h1>
                        </div>
                        <hr>
                        <div class="colomn_task_block"></div>
                    `;

                    const taskBlock = columnDiv.querySelector(".colomn_task_block");

                    // ---------- задачи ----------
                    column.tasks.forEach((task) => {
                        const tagsHTML = task.tags.map(tag => `
                            <div class="tag glass-block">
                                <h1 class="tegs_text task_text">${tag.name}</h1>
                            </div>
                        `).join("");

                        const subtasksHTML = task.subtasks.map(sub => `
                            <div class="subtask">
                                <input type="checkbox" class="glass-input-checkbox" ${sub.completed ? "checked" : ""} onclick="event.stopPropagation()" onchange="window.toggleSubtaskCompleted(${task.id}, ${sub.id}, this)">
                                <h1 class="subtask_title task_text">${sub.name}</h1>
                            </div>
                        `).join("");

                        const deadline = task.finished_at
                            ? new Date(task.finished_at).toLocaleString()
                            : "—";

                        const taskDiv = document.createElement("div");
                        taskDiv.className = "task glass-block";
                        taskDiv.dataset.id = task.id;
                        taskDiv.dataset.name = (task.name ?? "").toString();
                        taskDiv.draggable = true; // Make task draggable

                        // Add drag events to task
                        taskDiv.addEventListener('dragstart', handleDragStart);
                        taskDiv.addEventListener('dragend', handleDragEnd);

                        taskDiv.innerHTML = `
                            <h1 class="name task_text" onclick="open_task_by_id(${task.id})">${task.name}</h1>
                            <h1 class="discription task_text">${task.description || ""}</h1>
                            <hr>

                            ${subtasksHTML ? subtasksHTML + "<hr>" : ""}

                            <h1 class="deadline task_text">Срок: ${deadline}</h1>

                            <div class="tags">
                                ${tagsHTML}
                            </div>
                        `;

                        taskBlock.appendChild(taskDiv);
                    });

                    // ---------- добавляем колонку на доску ----------
                    canban_board.appendChild(columnDiv);
                });

                // кнопка "добавить категорию" остаётся в конце
                const addCategory = document.createElement("div");
                addCategory.className = "add_category";
                canban_board.appendChild(addCategory);

                applyTaskFilter();
            });
        }

        // Drag and Drop Handlers
        let draggedTask = null;
        
        // Auto Scroll State
        let isDragging = false;
        let dragMouseX = 0;
        let dragMouseY = 0;
        let dragScrollAnimationId = null;
        const SCROLL_ZONE = 100;
        const SCROLL_STEP = 10;
        const VERTICAL_SCROLL_ZONE = 60;
        const VERTICAL_SCROLL_STEP = 5;

        function startAutoScroll() {
            if (dragScrollAnimationId) return;
            
            function step() {
                if (!isDragging) {
                    dragScrollAnimationId = null;
                    return;
                }

                // Horizontal Scroll (Board)
                const board = document.querySelector('.conban-board');
                if (board) {
                    const width = window.innerWidth;
                    if (dragMouseX < SCROLL_ZONE) {
                        board.scrollLeft -= SCROLL_STEP;
                    } else if (dragMouseX > width - SCROLL_ZONE) {
                        board.scrollLeft += SCROLL_STEP;
                    }
                }

                // Vertical Scroll (Column)
                // Find element under cursor to see if it's inside a column
                const el = document.elementFromPoint(dragMouseX, dragMouseY);
                if (el) {
                    const columnBlock = el.closest('.colomn_task_block');
                    if (columnBlock) {
                        const rect = columnBlock.getBoundingClientRect();
                        const relY = dragMouseY - rect.top;
                        const bottomRelY = rect.bottom - dragMouseY;

                        if (relY < VERTICAL_SCROLL_ZONE) {
                            columnBlock.scrollTop -= VERTICAL_SCROLL_STEP;
                        } else if (bottomRelY < VERTICAL_SCROLL_ZONE) {
                            columnBlock.scrollTop += VERTICAL_SCROLL_STEP;
                        }
                    }
                }
                
                dragScrollAnimationId = requestAnimationFrame(step);
            }
            
            dragScrollAnimationId = requestAnimationFrame(step);
        }

        function stopAutoScroll() {
            if (dragScrollAnimationId) {
                cancelAnimationFrame(dragScrollAnimationId);
                dragScrollAnimationId = null;
            }
        }

        function updateDragMousePosition(e) {
            dragMouseX = e.clientX;
            dragMouseY = e.clientY;
            // Prevent default to allow drop
            e.preventDefault(); 
        }

        function handleDragStart(e) {
            draggedTask = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', this.dataset.id);

            // Init Auto Scroll
            isDragging = true;
            // We attach to document to catch dragover anywhere
            document.addEventListener('dragover', updateDragMousePosition);
            startAutoScroll();
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
            draggedTask = null;
            document.querySelectorAll('.column').forEach(col => col.classList.remove('drag-over'));
            
            // Cleanup Auto Scroll
            isDragging = false;
            stopAutoScroll();
            document.removeEventListener('dragover', updateDragMousePosition);
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            this.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            this.classList.remove('drag-over');
        }

        async function handleDrop(e) {
            e.preventDefault();
            this.classList.remove('drag-over');

            const taskId = e.dataTransfer.getData('text/plain');
            const newColumnId = this.dataset.id;
            const statusId = parseInt(newColumnId);
            
            if (!taskId || !newColumnId || isNaN(statusId)) {
                console.error("Invalid Drop Data", {taskId, newColumnId, statusId});
                return;
            }

            // Optimistic UI update
            const taskElement = document.querySelector(`.task[data-id='${taskId}']`);
            const targetTaskBlock = this.querySelector('.colomn_task_block');
            
            if (taskElement && targetTaskBlock) {
                targetTaskBlock.appendChild(taskElement);
                
                // Send request to server
                try {
                    await request({
                        url: `/task/${taskId}/status/`,
                        method: 'PATCH',
                        body: {
                            status_id: statusId
                        }
                    });
                    console.log('Task status updated successfully');
                } catch (error) {
                    console.error('Failed to update task status:', error);
                    // Revert changes if needed or show error notification
                    alert('Не удалось обновить статус задачи: ' + (error.message ? JSON.stringify(error.message) : 'Unknown error'));
                    // Reload to sync state
                    show_canban_list();
                }
            }
        }

        show_canban_list();
        initTaskSearch();

        async function open_create_task_page() {
            const url = categoryId ? `/task/create/?category_id=${encodeURIComponent(categoryId)}` : "/task/create/";
            const resp = await fetch(url, { method: "GET" });
            const data = await resp.text();

            const view = document.querySelector('.view_task_section');
            view.innerHTML = '';
            await setHTMLWithScripts(view, data);   
            view.style.display = "flex";
        }

        // WebSocket Listener
        document.addEventListener('taskUpdate', function(e) {
            const data = e.detail;
            const task = data.task;
            
            // Remove existing if any
            const existing = document.querySelector(`.task[data-id="${task.id}"]`);
            if (existing) existing.remove();
            
            // Determine column
            const statusId = task.status ? task.status.id : null;
            if (!statusId) return; 
            
            const column = document.querySelector(`.column[data-id="${statusId}"]`);
            if (!column) return; 
            
            const taskBlock = column.querySelector('.colomn_task_block');
            if (!taskBlock) return;
            
            // Render task HTML
            const tagsHTML = (task.tags || []).map(tag => `
                <div class="tag glass-block">
                    <h1 class="tegs_text task_text">${tag.name}</h1>
                </div>
            `).join("");

            const subtasksHTML = (task.subtasks || []).map(sub => `
                <div class="subtask">
                    <input type="checkbox" class="glass-input-checkbox" ${sub.completed ? "checked" : ""} onclick="event.stopPropagation()" onchange="window.toggleSubtaskCompleted(${task.id}, ${sub.id}, this)">
                    <h1 class="subtask_title task_text">${sub.name}</h1>
                </div>
            `).join("");

            const deadline = task.finished_at
                ? new Date(task.finished_at).toLocaleString()
                : "—";

            const taskDiv = document.createElement("div");
            taskDiv.className = "task glass-block";
            taskDiv.dataset.id = task.id;
            taskDiv.dataset.name = (task.name ?? "").toString();
            taskDiv.draggable = true;

            taskDiv.addEventListener('dragstart', handleDragStart);
            taskDiv.addEventListener('dragend', handleDragEnd);

            taskDiv.innerHTML = `
                <h1 class="name task_text" onclick="open_task_by_id(${task.id})">${task.name}</h1>
                <h1 class="discription task_text">${task.description || ""}</h1>
                <hr>

                ${subtasksHTML ? subtasksHTML + "<hr>" : ""}

                <h1 class="deadline task_text">Срок: ${deadline}</h1>

                <div class="tags">
                    ${tagsHTML}
                </div>
            `;

            taskBlock.appendChild(taskDiv);
            
            if (typeof applyTaskFilter === 'function') {
                applyTaskFilter();
            }
        });
    </script>
{% endblock %}
